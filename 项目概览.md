# 项目分析报告

本文档旨在全面分析 `blog` 项目的架构、模块功能和技术栈。该项目是一个基于微服务架构的博客平台，由一个前端应用程序、三个业务后端服务以及一个服务发现中心组成。

## 1. 项目整体架构

本项目采用前后端分离的微服务架构，具体包含以下五个核心模块：

1.  **`blog-frontend` (前端应用)**: 一个基于 Vue.js 3 的单页面应用 (SPA)，为用户提供交互界面。
2.  **`blog-article-service` (文章服务)**: 一个 Spring Boot 微服务，负责管理博客文章的内容、元数据和标签。
3.  **`blog-auth-service` (认证服务)**: 一个 Spring Boot 微服务，负责处理用户认证、授权和 Token 管理。
4.  **`blog-user-service` (用户服务)**: 一个 Spring Boot 微服务，负责管理用户账户信息、认证凭证和用户资料。
5.  **`blog-eureka-server` (服务发现中心)**: 一个 Spring Cloud Eureka Server，为所有后端服务提供注册与发现能力。

四个模块之间的交互关系如下：

- 用户通过 **`blog-frontend`** 与应用交互。
- 前端应用通过 API 请求与后端服务通信。所有与文章相关的请求（如获取、创建、搜索文章）都发送到 **`blog-article-service`**。
- 当用户进行登录时，前端应用会与 **`blog-auth-service`** 通信。当用户注册时，前端应用直接调用 **`blog-user-service`**。
- **`blog-auth-service`** 在验证用户登录时，会通过 Eureka 发现并调用 **`blog-user-service`** 的内部接口来获取用户的认证凭证（加密后的密码）。
- **`blog-article-service`** 在展示文章时，会通过 Eureka 发现并调用 **`blog-user-service`** 来获取作者的详细信息。
- 后端服务之间的通信通过 Spring Cloud OpenFeign 实现，支持声明式 REST 调用和断路器模式。

![架构图](https://i.imgur.com/9yY4w2C.png)

---

## 2. 模块详细分析

### 2.1. `blog-frontend` (前端应用)

前端是一个现代化的 Vue.js 项目，使用 Vite 作为构建工具，具备响应式界面和高效的状态管理。

- **技术栈**:

  - **框架**: Vue.js 3
  - **构建工具**: Vite
  - **路由**: `vue-router`
  - **状态管理**: Pinia
  - **HTTP 客户端**: Axios
  - **UI 库**: Element Plus

- **文件结构与功能**:
  - `package.json`: 定义了项目依赖（如 `vue`, `pinia`, `axios`）和脚本（`dev`, `build`）。
  - `vite.config.js`: 配置文件。其中设置了 **API 代理**，将 `/api` 请求转发到后端的文章服务 (`http://localhost:8082`)，解决了跨域问题。
  - `src/main.js`: 应用入口文件，初始化 Vue 实例、Pinia 和路由。
  - `src/router/index.js`: 定义了应用的全部路由，包括公共路由（如首页 `BlogView`）和需要认证的私有路由（如 `CreateArticleView`, `EditArticleView`），通过 `meta: { requiresAuth: true }` 标记实现路由守卫。
  - `src/stores/`: Pinia 状态管理中心。
    - `authStore.js`: 负责管理用户认证状态，包括 Token、用户信息、登录/注销逻辑，并将认证信息持久化到 `localStorage`。
    - `articleStore.js`: 负责管理文章数据，包括获取文章列表、分页、筛选（按标签、作者、关键词）、加载状态和错误处理。
  - `src/services/`: API 服务层。
    - `api.js`: 封装了与 `blog-article-service` 交互的 API 请求。
    - `auth.js`: 封装了与 `blog-auth-service` 交互的 API 请求。
  - `src/views/`: 页面级组件，对应各个路由。
  - `src/components/`: 可复用的 UI 组件，如 `ArticleCard.vue` 和 `LoginModal.vue`。

### 2.2. `blog-article-service` (文章服务)

这是一个功能强大的 Spring Boot 微服务，负责博客文章的所有核心业务逻辑。

- **技术栈**:

  - **框架**: Spring Boot
  - **数据库**: PostgreSQL (存储文章元数据，如标题、作者、标签) 和 MongoDB (存储文章正文)。
  - **数据访问**: Spring Data JPA (PostgreSQL), Spring Data MongoDB, MyBatis-Plus。
  - **服务治理**: Spring Cloud Netflix Eureka (服务发现，可配置开关)。
  - **服务调用**: Spring Cloud OpenFeign (用于服务间通信)。
  - **容错机制**: Resilience4j (实现断路器，提高系统弹性)。

- **文件结构与功能**:
  - `pom.xml`: 定义了所有 Maven 依赖，包括 Web、JPA、MongoDB、Eureka、OpenFeign 和 Resilience4j。
  - `src/main/resources/application.yml`: 核心配置文件。
    - 服务端口设置为 `8082`。
    - 配置了 PostgreSQL 和 MongoDB 的数据库连接信息，并支持通过环境变量覆盖。
  - 配置了 Eureka 客户端，并默认启用；可通过 `EUREKA_ENABLED`/`EUREKA_URI` 环境变量控制注册行为。
    - 为 OpenFeign 客户端启用了断路器 (`circuitbreaker: enabled: true`)。
    - 配置了 Resilience4j 断路器实例 `userService`，用于保护对用户服务的调用。
  - `src/main/java/com/example/blog/article/`:
    - `controller/`: 定义了 RESTful API 接口，供前端或其他服务调用。
    - `service/`: 包含了核心业务逻辑，如文章的增删改查、内容存储和标签管理。
    - `repository/`: 数据访问层接口，使用 Spring Data JPA/MongoDB。
    - `entity/`: 定义了与数据库表/集合对应的实体类。
    - `client/`: OpenFeign 客户端接口，用于声明式地调用其他微服务。

### 2.3. `blog-auth-service` (认证服务)

这是一个专门负责安全认证的 Spring Boot 微服务，采用基于 JWT (JSON Web Token) 的无状态认证机制。

- **技术栈**:

  - **框架**: Spring Boot
  - **安全框架**: Spring Security
  - **Token 技术**: JJWT (Java JWT library)
  - **缓存/存储**: Redis (用于存储 JWT 黑名单，实现注销功能)。

- **文件结构与功能**:
  - `pom.xml`: 包含了 Spring Security、Data Redis 和 JJWT 等核心依赖。
  - `src/main/resources/application.yml`: 核心配置文件。
    - 服务端口设置为 `8081`。
    - 配置了 Redis 的连接信息。
    - 定义了 JWT 相关的配置，包括 **密钥 (`secret-key`)** 和 **访问/刷新令牌的过期时间**。密钥支持通过环境变量 `JWT_SECRET_KEY` 进行配置，增强了安全性。
  - `src/main/java/com/example/blog/auth/`:
    - `controller/`: 提供了登录、注册、刷新 Token 等认证相关的 API 端点。
    - `security/`: Spring Security 的核心配置，包括安全过滤器链、JWT 解析与验证逻辑、密码编码器等。
    - `service/`: 实现了用户认证、Token 生成与吊销（通过 Redis 黑名单）等业务逻辑。
    - `dto/`: 数据传输对象，用于在不同层之间传递数据（如登录请求体）。

### 2.4. `blog-user-service` (用户服务)

这是一个专门负责用户账户管理的 Spring Boot 微服务，是用户领域的权威数据源。

- **技术栈**:

  - **框架**: Spring Boot
  - **数据库**: PostgreSQL (存储用户资料和认证凭证)。
  - **数据访问**: MyBatis-Plus。
  - **安全**: Spring Security (提供 BCrypt 密码加密器)。
  - **服务治理**: Spring Cloud Netflix Eureka (服务发现，可配置开关)。

- **文件结构与功能**:

  - `pom.xml`: 包含了 Spring Web、Spring Security、MyBatis-Plus、PostgreSQL Driver 和 Eureka Client 等依赖。
  - `src/main/resources/application.yml`: 核心配置文件。
    - 服务端口设置为 `8083`。
    - 配置了 PostgreSQL 数据库连接 (`blog_user_db`)。
  - 配置了 Eureka 客户端，默认启用；需要关闭时可将 `EUREKA_ENABLED` 设置为 `false`。
    - 启用了 Hibernate 的 `ddl-auto: update`，自动创建和更新表结构。
  - `src/main/java/com/example/blog/user/`:
    - `entity/`: 定义了 `User` (用户资料) 和 `UserAuth` (认证凭证) 两个实体类。
    - `dto/`: 包含 `RegistrationRequest` (注册请求)、`UserDTO` (公开用户信息) 和 `UserAuthDetailsDTO` (内部认证详情) 三个 DTO。
    - `mapper/`: MyBatis-Plus 数据访问接口，提供 CRUD 操作。
    - `config/SecurityConfig.java`: 配置 BCrypt 密码编码器和 HTTP 安全策略。
    - `service/`: 实现了用户注册（密码加密）、用户查询和认证凭证查询的核心业务逻辑。
    - `controller/`: 提供了三个 REST 端点：用户注册、获取用户信息和获取认证详情（内部接口）。

- **核心功能**:
  - **用户注册**: 验证昵称和标识符的唯一性，使用 BCrypt 加密密码后存储。
  - **用户资料管理**: 存储和检索用户的公开资料（昵称、头像、简介）。
  - **认证凭证提供**: 为 `blog-auth-service` 提供内部 API，返回加密的密码和账户状态用于登录验证。
  - **作者信息服务**: 为 `blog-article-service` 提供文章作者的详细信息。

### 2.5. `blog-eureka-server` (服务发现中心)

这是统一的服务注册与发现中心，为所有 Spring Boot 微服务提供实例管理和健康检查能力。

- **技术栈**:

  - **框架**: Spring Boot
  - **服务治理**: Spring Cloud Netflix Eureka Server
  - **监控**: Spring Boot Actuator，用于暴露健康端点

- **文件结构与功能**:
  - `pom.xml`: 定义了 Eureka Server、Web、Actuator 等依赖。
  - `src/main/resources/application.yml`: 监听端口 `8761`，禁用了自注册与自拉取，避免服务器把自己当作客户端。
  - `Dockerfile`: 提供容器化构建，方便通过 `docker-compose` 一键启动服务发现中心。
  - `start-all-services.ps1`: 在其他服务启动前自动编译并运行 Eureka Server，确保业务服务能够顺利注册。

---

## 3. 核心业务流程

### 3.1. 用户注册

1. 用户在 `blog-frontend` 的注册界面填写昵称、账号标识和密码。
2. 前端调用用户服务暴露的 `POST /api/users/register` 接口（通过 Vite 代理转发到 `http://localhost:8083`）。
3. `blog-user-service` 使用 Bean Validation 校验入参，借助 MyBatis-Plus 检查昵称和标识符唯一性，并通过 `BCryptPasswordEncoder` 加密密码后写入 `t_user` 与 `t_user_auth` 表。
4. 注册成功后返回标准化的 `UserDTO`，前端在 Pinia 的 `authStore` 中缓存基础资料，确保账号创建与后续登录衔接顺畅。

### 3.2. 用户登录与会话维持

1. 登录请求发送到认证服务的 `POST /api/auth/login` 接口，前端 `authStore` 使用 Axios 客户端 `authServiceClient` 完成调用。
2. `blog-auth-service` 借助 OpenFeign 调用用户服务的内部认证接口，获取加密凭证并使用 Spring Security 校验用户名/密码。
3. 校验成功后认证服务生成 Access Token（默认 1 小时）与 Refresh Token（默认 7 天），并把登录上下文写入响应。前端将 Token 持久化到 `localStorage`。
4. 后续所有发往文章、用户、通知接口的请求都会经过 Axios 拦截器自动附加 `Authorization: Bearer <access_token>`。如果 Access Token 过期，前端会利用 `/api/auth/refresh` 重新获取新令牌。
5. 用户登出或刷新令牌被吊销时，认证服务把 Access Token 标识写入 Redis 黑名单并设置 TTL，保证已注销的令牌立即失效。

### 3.3. 受保护 API 调用链路

1. 前端访问需要鉴权的页面（如文章创作、个人通知）时，路由守卫会检查本地 Token 并决定是否跳转登录。
2. 后端服务通过统一的 `JwtAuthenticationFilter` 解析请求头中的 Token，校验签名并检查是否存在于 Redis 黑名单。
3. 提取到的用户 ID 会注入 Spring Security 上下文，供控制器和业务服务直接使用；验证失败则返回 `401/403`，前端拦截器负责处理刷新或登出流程。

### 3.4. 文章创建、存储与聚合

1. 登录用户在 `CreateArticleView` 中提交内容，前端通过 `POST /api/articles` 将请求发送到 `blog-article-service`。
2. 文章服务把结构化元数据写入 PostgreSQL 的 `t_article`、标签写入 `t_tag`/`t_article_tag`，并将正文写入 MongoDB 的 `article_content` 集合，形成冷热数据分层。
3. 在返回文章详情和列表时，文章服务使用用户服务的 Feign 客户端补全作者昵称、头像等展示信息，同时由 Resilience4j 断路器保护跨服务调用的稳定性。
4. 前端的 `articleStore` 缓存文章集合，提供分页、标签筛选、关键字搜索等功能，支撑首页 (`BlogView`) 和详情页的快速响应体验。

### 3.5. 点赞、评论与通知协同

1. 用户在文章详情页的点赞或评论操作会调用文章服务的交互接口（例如 `POST /api/articles/{id}/likes`、`POST /api/articles/{id}/comments`），请求携带 Access Token 以标识当前用户。
2. 文章服务在 PostgreSQL 中维护点赞去重表和评论表，并同步刷新 `t_article` 中的统计字段，确保列表展示无需额外聚合查询。
3. 服务还会通过 `NotificationClient` 调用用户服务生成通知，构造 `CreateNotificationRequest` 写入 `t_notification`，为作者创建“文章被点赞/评论”的提醒。
4. 用户服务通过 `/api/notifications/me` 等端点向前端暴露通知数据，`notificationsStore` 负责管理未读状态和批量已读，保证互动体验闭环。

### 3.6. 静态资源与头像上传

1. 头像裁剪组件会将表单数据上传到用户服务的 `POST /api/users/me/avatar` 接口。
2. 用户服务按照配置的 `uploads/avatars` 目录保存文件并返回统一的静态资源 URL。
3. Vite 代理把 `/uploads` 前缀转发至用户服务，使前端无需额外反向代理即可加载头像、封面等静态资源。

## 4. 整体功能总结

该博客平台实现了以下核心功能：

1.  **用户认证**:

- 用户可以注册和登录。
- 采用 JWT 进行无状态认证，包含访问令牌 (Access Token) 和刷新令牌 (Refresh Token) 机制。
- 支持用户注销，通过将 JWT 加入 Redis 黑名单实现。

2.  **文章管理**:

- 认证用户可以创建、编辑和删除自己的文章。
- 文章元数据（标题、摘要、作者等）存储在 PostgreSQL 中，便于关系查询。
- 文章正文存储在 MongoDB 中，适合大文本存储。
- 支持对文章进行 **多维度搜索和筛选**，包括：
  - 按关键词搜索。
  - 按一个或多个标签筛选。
  - 按作者筛选。
  - 按文章状态（如已发布、草稿）筛选。

3.  **前端体验**:

- 响应式的 UI 设计，适配不同设备。
- 通过路由守卫保护需要登录才能访问的页面。
- 使用状态管理库 Pinia 统一管理应用状态，保证数据的一致性。
- 通过 API 代理与后端服务顺畅通信。

4.  **微服务特性**:

- 服务可独立部署和扩展。
- 通过 Eureka 实现服务注册与发现（可选）。
- 通过 OpenFeign 和 Resilience4j 实现健壮的服务间调用和容错。

---

## 5. 数据库结构设计

`blog-article-service` 采用了混合持久化策略，将不同类型的数据存储在最适合的数据库中，以兼顾查询性能和存储灵活性。

### 5.1. PostgreSQL 数据库结构

PostgreSQL 用于存储结构化的元数据，这些数据具有明确的关系，适合进行复杂的关联查询。

- **数据库名**: `blog_article_db`

#### 表结构

1.  **`t_article` (文章表)**

    - **功能**: 存储文章的核心元数据，不包含正文。
    - **字段**:
      - `id` (BIGINT, 主键, 自增): 唯一标识符。
      - `author_id` (BIGINT): 作者的用户 ID。
      - `title` (VARCHAR): 文章标题。
      - `summary` (TEXT): 文章摘要。
      - `cover_image_url` (VARCHAR): 封面图片 URL。
      - `status` (VARCHAR): 文章状态 (`DRAFT`, `PUBLISHED`, `PRIVATE`, `DELETED`)。
      - `publish_time` (TIMESTAMP): 发布时间。
      - `view_count` (INT): 浏览量。
      - `like_count` (INT): 点赞数。
      - `comment_count` (INT): 评论数。
      - `created_at` (TIMESTAMP): 创建时间。
      - `updated_at` (TIMESTAMP): 更新时间。

2.  **`t_tag` (标签表)**

    - **功能**: 存储所有可用的标签。
    - **字段**:
      - `id` (BIGINT, 主键, 自增): 标签唯一标识符。
      - `name` (VARCHAR, 唯一): 标签名称。
      - `color` (VARCHAR): 标签颜色代码（用于前端展示）。
      - `created_at` (TIMESTAMP): 创建时间。
      - `updated_at` (TIMESTAMP): 更新时间。

3.  **`t_article_tag` (文章-标签关联表)**
    - **功能**: 建立 `t_article` 和 `t_tag` 之间的多对多关系。
    - **字段**:
      - `article_id` (BIGINT, 外键 -> `t_article.id`): 文章 ID。
      - `tag_id` (BIGINT, 外键 -> `t_tag.id`): 标签 ID。
      - `created_at` (TIMESTAMP): 关联创建时间。
    - **约束**: (`article_id`, `tag_id`) 构成复合主键，确保唯一性。

### 5.2. MongoDB 数据库结构

MongoDB 用于存储非结构化的文章正文，其灵活的文档模型非常适合存储大段的 Markdown 或 HTML 内容。

- **数据库名**: `blog_content_db`

#### 集合结构

1.  **`article_content` (文章内容集合)**
    - **功能**: 存储文章的详细正文。
    - **文档结构**:
      - `_id` (ObjectId, 主键): MongoDB 自动生成的唯一 ID。
      - `articleId` (String): 对应 PostgreSQL 中 `t_article` 表的 `id`，用于关联元数据。
      - `content` (String): 文章的完整内容（Markdown 或 HTML 格式）。
      - `createdAt` (Date): 创建时间。
      - `updatedAt` (Date): 更新时间。

### 5.3. 数据初始化

- **JPA/Hibernate DDL-Auto**: `application.yml` 中配置了 `spring.jpa.hibernate.ddl-auto: update`，这意味着在服务启动时，Hibernate 会自动检查并更新 PostgreSQL 的表结构，无需手动执行 SQL 创建表。
- **手动初始化**: 项目中提供了 `init-tags.sql` 脚本，可用于预先填充一些示例标签到 `t_tag` 表中，方便开发和测试。

### 5.4. blog-user-service 数据库结构

`blog-user-service` 使用 PostgreSQL 存储所有用户相关数据，采用分离式设计，将用户资料和认证凭证存储在不同的表中。

#### PostgreSQL 数据库结构

- **数据库名**: `blog_user_db`

**表结构：**

1.  **`t_user` (用户表)**

    - **功能**: 存储用户的基本资料信息。
    - **字段**:
      - `id` (BIGINT, 主键, 自增): 用户唯一标识符。
      - `nickname` (VARCHAR, 唯一, 非空): 用户昵称。
      - `avatar_url` (VARCHAR): 头像图片 URL。
      - `bio` (TEXT): 用户简介。
      - `status` (INTEGER): 账户状态 (0:正常, 1:禁用, 2:待激活, 3:已注销)。
      - `created_at` (TIMESTAMP): 创建时间。
      - `updated_at` (TIMESTAMP): 更新时间。

2.  **`t_user_auth` (用户认证表)**
    - **功能**: 存储用户的认证凭证，支持多种认证方式。
    - **字段**:
      - `id` (BIGINT, 主键, 自增): 认证记录唯一标识符。
      - `user_id` (BIGINT, 外键 -> `t_user.id`): 关联的用户 ID。
      - `identity_type` (VARCHAR, 非空): 认证类型 (如 "email", "username", "phone", "wechat" 等)。
      - `identifier` (VARCHAR, 非空): 唯一标识符（如邮箱地址、用户名、手机号等）。
      - `credential` (VARCHAR, 非空): 凭证（BCrypt 加密的密码或 OAuth Token）。
      - `created_at` (TIMESTAMP): 创建时间。
      - `updated_at` (TIMESTAMP): 更新时间。
    - **唯一约束**: (`identity_type`, `identifier`) 组合唯一，确保同一种认证方式下标识符不重复。

**设计亮点：**

- **多认证方式支持**: 一个用户可以有多条 `t_user_auth` 记录，支持邮箱登录、用户名登录、手机号登录、OAuth 等多种方式。
- **安全性**: 敏感的认证凭证与用户资料分离存储，密码使用 BCrypt 不可逆加密。
- **扩展性**: 新增认证方式只需添加新的 `identity_type`，无需修改表结构。

#### 数据初始化

- **JPA/Hibernate DDL-Auto**: `application.yml` 中配置了 `spring.jpa.hibernate.ddl-auto: update`，服务启动时自动创建和更新表结构。
- **无需手动建表**: MyBatis-Plus 和 Hibernate 会根据实体类自动生成表结构。

### 5.5. blog-auth-service 数据存储

`blog-auth-service` 使用 Redis 进行轻量级数据存储：

- **用途**: 存储 JWT 黑名单（已注销的 Token）。
- **数据结构**: Key-Value 存储，Key 为 JWT Token 的唯一标识，Value 为过期时间。
- **TTL 机制**: 利用 Redis 的自动过期功能，Token 在过期后自动从黑名单中删除。

---

## 6. 外部依赖与 Docker 配置

为了在本地环境中完整地运行此项目，需要以下外部依赖服务：

1.  **PostgreSQL**: 用于 `blog-article-service`，存储文章的元数据、标签等关系型数据。
2.  **MongoDB**: 用于 `blog-article-service`，存储文章的正文内容。
3.  **Redis**: 用于 `blog-auth-service`，存储 JWT 黑名单以实现用户注销功能。

推荐使用 Docker 和 Docker Compose 来统一管理这些服务，以简化环境配置。

### 6.1. Docker Compose 配置

在项目根目录下创建一个 `docker-compose.yml` 文件，内容如下。该文件定义了所有必需的服务、端口映射和环境变量。

```yaml
version: "3.8"

services:
  # PostgreSQL 数据库服务
  postgres:
    image: postgres:14-alpine
    container_name: blog-postgres
    environment:
      POSTGRES_DB: blog_article_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "15432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - blog-network

  # MongoDB 数据库服务
  mongo:
    image: mongo:latest
    container_name: blog-mongo
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: password
      MONGO_INITDB_DATABASE: blog_content_db
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db
    networks:
      - blog-network

  # Redis 缓存服务
  redis:
    image: redis:alpine
    container_name: blog-redis
    ports:
      - "6379:6379"
    networks:
      - blog-network

volumes:
  postgres_data:
  mongo_data:

networks:
  blog-network:
    driver: bridge
```

**如何运行:**

在包含 `docker-compose.yml` 文件的目录下，执行以下命令启动所有服务：

```bash
docker-compose up -d
```

### 5.2. 应用服务配置

后端微服务（`blog-article-service` 和 `blog-auth-service`）的 `application.yml` 文件已经过精心设计，可以通过环境变量来动态配置数据库和 Redis 的连接信息。

当使用上述 `docker-compose.yml` 启动依赖服务后，**无需修改任何 `application.yml` 文件**，因为默认配置与 Docker 配置一致。

- **`blog-article-service` 的连接配置**:

  - **PostgreSQL**: `application.yml` 中的 `spring.datasource.url` 等属性会使用 `${DB_HOST:localhost}` 这样的语法。这意味着如果环境变量 `DB_HOST` 未设置，它将默认使用 `localhost`，这正好是 Docker 端口映射的主机。
  - **MongoDB**: 同理，`spring.data.mongodb.uri` 也使用了环境变量和默认值。

- **`blog-auth-service` 的连接配置**:
  - **Redis**: `spring.data.redis.host` 使用 `${REDIS_HOST:localhost}`，默认连接到本地运行的 Redis 实例。

如果需要将后端服务也容器化并连接到这些依赖，只需将 `localhost` 替换为 Docker Compose 中定义的服务名（例如 `postgres`, `mongo`, `redis`），并确保它们在同一个 Docker 网络中。

---

## 7. 最新功能改进

近期针对文章互动功能进行了重要增强，重点包括：

- **点赞/取消点赞 API 完成**：`ArticleServiceImpl` 中新增了点赞去重、幂等校验与计数更新逻辑，`ArticleLikeRepository` 负责持久化用户点赞记录。
- **评论 CRUD 完整化**：实现评论创建、删除接口，同时在服务层同步维护 `t_article` 中的评论总数，避免聚合查询开销。
- **DTO 数据对齐**：`ArticleSummaryDTO` 增加 `likesCount`、`commentsCount` 字段，并在文章详情和分页接口的 DTO 构建流程中填充，默认值回退为 0 以避免前端展示异常。
- **数据库脚本更新**：`add-likes-and-comments-tables.sql` 与 `update-articles-table-for-counts.sql` 确保 Postgres 中存在 `t_article_like`、`t_article_comment`，并在 `t_article` 表上新增计数字段，与代码逻辑保持一致。

---

## 7. 测试与验证

- **单接口验证**：通过 PowerShell `Invoke-RestMethod` 对 `/api/articles/{id}/likes`、`/api/articles/{id}/comments` 的 POST/DELETE/GET 端点进行手工验证，确认点赞幂等性和评论生命周期操作均返回 2xx。
- **数据库核对**：结合 `docker exec` 进入 PostgreSQL 容器，使用 `SELECT` 查询核实 `t_article` 与关联表计数同步更新。
- **持续构建**：执行 `mvn clean compile -DskipTests` 确保编译通过，暂未补充自动化测试用例，存在潜在回归风险。

---

## 8. 待办事项与建议

1. **前端交互实现**：在 `blog-frontend` 中扩展服务层 (`src/services/api.js`) 以及组件（如 `ArticleDetailView.vue`），增加点赞/取消点赞按钮与评论操作 UI，并与 Pinia 状态保持一致。
2. **接口权限校验**：针对点赞、评论操作补充基于 JWT 的路由守卫与请求头处理，避免匿名访问导致的 401 异常。
3. **自动化测试补齐**：在文章服务中添加接口级集成测试，覆盖点赞/评论计数同步场景，同时考虑为前端加入端到端测试以验证互动流程。
4. **监控与日志**：为点赞、评论模块加入结构化日志与必要的指标上报（如通过 Micrometer），便于后续运维与告警。

---

## 9. 性能与扩展性评估

- **读写分离潜力**：文章元数据与正文分布在 PostgreSQL/MongoDB，可根据访问量将阅读频繁的正文使用 CDN 或静态缓存下发，降低数据库负载。
- **热点数据缓存**：可在文章列表、详情接口前置 Redis/本地缓存层，配合点赞、评论事件触发缓存失效，避免频繁命中数据库。
- **异步处理**：点赞计数和评论通知后续可通过消息队列（如 Kafka、RabbitMQ）异步落库，提高接口响应速度。
- **水平扩展**：各微服务已具备独立部署能力，结合容器编排（Kubernetes/Docker Swarm）可实现弹性扩缩容。
- **接口限流**：针对高频接口（点赞、评论、搜索）建议接入限流策略（如基于 Redis 的滑动窗口算法），保障服务稳定性。

---

## 10. 安全性考虑

- **Token 传输与存储**：前端需确保在 HTTPS 环境中通过 `Authorization` 头传输 JWT，避免中间人攻击；敏感信息不应存储在可被脚本访问的地方（可考虑 HttpOnly Cookie + CSRF 保护）。
- **输入校验**：评论内容需在后端进行严格校验与转义，防止 XSS/SQL 注入；MongoDB 写入正文时也需过滤潜在脚本。
- **权限审计**：点赞/评论删除需验证用户身份，避免越权；建议补充操作日志，记录用户行为以便审计。
- **速率限制与防刷**：对点赞/评论操作加上用户级别的频率限制，结合 IP 黑名单减少恶意刷量。
- **依赖安全更新**：定期使用 `mvn versions:display-dependency-updates`、`npm audit` 等工具检查后端/前端依赖漏洞。

---

## 11. 部署与运维建议

- **环境分层**：至少区分 `dev`、`staging`、`prod` 三套环境，利用环境变量注入数据库、Redis、消息队列等配置。
- **CI/CD 流程**：推荐使用 GitHub Actions 或 Jenkins 构建流水线，自动进行单元测试、Docker 镜像构建与部署。
- **日志收集**：集中化日志方案（ELK/EFK）便于跨服务排障，新增的点赞/评论操作需输出关键字段（用户 ID、文章 ID、耗时等）。
- **健康检查**：为每个服务暴露 `/actuator/health` 等健康端点，配合部署平台实现自愈。
- **备份策略**：定期备份 PostgreSQL、MongoDB 数据，结合 Redis 持久化方案（AOF）保障数据安全。

---

## 12. 总结

`blog` 项目已经具备完整的微服务体系和核心博客功能，近期完成的点赞与评论改造进一步提升了用户互动体验。当前重点在于前端功能补齐与测试体系建设，同时需要关注性能、权限与运维等方面的长远规划。按照本报告中的建议持续推进，可逐步实现可观测、可扩展、可维护的生产级博客平台。
